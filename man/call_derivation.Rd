% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/call_derivation.R
\name{call_derivation}
\alias{call_derivation}
\title{Call a Single Derivation Multiple Times}
\usage{
call_derivation(dataset = NULL, derivation, variable_params, ...)
}
\arguments{
\item{dataset}{Input dataset

\describe{
\item{Default value}{\code{NULL}}
}}

\item{derivation}{The derivation function to call

A function that performs a specific derivation is expected. A derivation
adds variables or observations to a dataset. The first argument of a
derivation must expect a dataset and the derivation must return a dataset.
All expected arguments for the derivation function must be provided through
the \code{params()} objects passed to the \code{variable_params} and \code{...} arguments.

\describe{
\item{Default value}{none}
}}

\item{variable_params}{A \code{list} of function arguments that are different across iterations.
Each set of function arguments must be created using \code{\link[=params]{params()}}.

\describe{
\item{Default value}{none}
}}

\item{...}{Any number of \emph{named} function arguments that stay the same across iterations.
If a function argument is specified both inside \code{variable_params} and \code{...} then
the value in \code{variable_params} overwrites the one in \code{...}.

@details

It is also possible to pass functions from outside the \code{{admiral}} package
to \code{call_derivation()}, e.g. an extension package function, or
\code{dplyr::mutate()}. The only requirement for a function being passed to \code{derivation} is that
it must take a dataset as its first argument and return a dataset.

\describe{
\item{Default value}{none}
}}
}
\value{
The input dataset with additional records/variables added depending on
which \code{derivation} has been used.
}
\description{
Call a single derivation multiple times with some parameters/arguments being fixed across
iterations and others varying.
}
\examples{
library(dplyr, warn.conflicts = FALSE)
adsl <- tribble(
  ~STUDYID,   ~USUBJID,      ~TRTSDT,      ~TRTEDT,
  "PILOT01", "01-1307",           NA,           NA,
  "PILOT01", "05-1377", "2014-01-04", "2014-01-25",
  "PILOT01", "06-1384", "2012-09-15", "2012-09-24",
  "PILOT01", "15-1085", "2013-02-16", "2013-08-18",
  "PILOT01", "16-1298", "2013-04-08", "2013-06-28"
) \%>\%
  mutate(
    across(TRTSDT:TRTEDT, as.Date)
  )

ae <- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID,     ~AESTDTC,     ~AEENDTC,
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "16-1298", "2013-06-08", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-06-08", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06"
)

adae <- ae \%>\%
  derive_vars_merged(
    dataset_add = adsl,
    new_vars = exprs(TRTSDT, TRTEDT),
    by_vars = exprs(USUBJID)
  )

## While `derive_vars_dt()` can only add one variable at a time, using `call_derivation()`
## one can add multiple variables in one go
call_derivation(
  dataset = adae,
  derivation = derive_vars_dt,
  variable_params = list(
    params(dtc = AESTDTC, date_imputation = "first", new_vars_prefix = "AST"),
    params(dtc = AEENDTC, date_imputation = "last", new_vars_prefix = "AEN")
  ),
  min_dates = exprs(TRTSDT),
  max_dates = exprs(TRTEDT)
)

## The above call using `call_derivation()` is equivalent to the following
adae \%>\%
  derive_vars_dt(
    new_vars_prefix = "AST",
    dtc = AESTDTC,
    date_imputation = "first",
    min_dates = exprs(TRTSDT),
    max_dates = exprs(TRTEDT)
  ) \%>\%
  derive_vars_dt(
    new_vars_prefix = "AEN",
    dtc = AEENDTC,
    date_imputation = "last",
    min_dates = exprs(TRTSDT),
    max_dates = exprs(TRTEDT)
  )
}
\seealso{
\code{\link[=params]{params()}} \code{\link[=restrict_derivation]{restrict_derivation()}} \code{\link[=call_derivation]{call_derivation()}}

Higher Order Functions: 
\code{\link{derivation_slice}()},
\code{\link{restrict_derivation}()},
\code{\link{slice_derivation}()}
}
\concept{high_order_function}
\keyword{high_order_function}
